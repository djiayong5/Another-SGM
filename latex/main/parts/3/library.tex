\section{Библиотека \emph{O-State}}
Как было показано в разделе~\ref{pattern-realization}, реализация паттерна \emph{O-State} представляет
некоторые технические сложности. Для упрощения реализации была разработана библиотека \emph{O-State}
на языке \emph{Java}~\cite{gosling05java}. Для большего удобства при построении программ, библиотека существенно использует 
особенности языка \emph{Java}, и особенности ее версии 1.5~\cite{gosling05java}. 
Например, в предлагаемой библиотеке используются механизмы \emph{Reflection}~\cite{ReflectionTutorial},
\emph{Annotations}~\cite{AnnotationsTutorial} и \emph{Generics}~\cite{GenericsTutorial}. 

Паттерн \emph{O-State}, описанный в разделе~\ref{pattern-o-state}, был несколько модифицирован с учетом
возможностей языка \emph{Java}~1.5. Опишем выполненные изменения:
\begin{itemize}
\item помимо приема и обработки событий, возможно также общение с внешней средой через некоторый
  интерфейс (как в паттерне \emph{State}). Вызовы методов регистрируются так же, как события, и делегируются
  состояниям, так же, как это делается при обработке события;
\item абстрактный класс \stClassName{AbstractState} заменен на соответствующий интерфейс \stClassName{IState};
\item описание класса получается не вызовом метода \stMethodName{getDiscriptor}, а при помощи механизма
  Annotations (рис.~\ref{annotations_and_discriptors});
\item роль \stClassName{StateIdentifier} выполняет класс \stClassName{java.lang.Class}.
\end{itemize}

Структура основных классов библиотеки \emph{O-State} отражена на диаграмме, изображенной на рис.~\ref{library_structure}.

\drawfigurex{}{angle=-90,width=155mm}{pic/OStateLibrary.eps}{Основные классы библиотеки \emph{O-State}}{library_structure}


\drawfigurex{}{angle=-90,width=155mm}{pic/AnnotationsAndDiscriptors.eps}
  {Использование механизма \emph{Annotations} в библиотеке \emph{O-State}}{annotations_and_discriptors}

Поясним функциональность основных классов библиотеки.
\begin{itemize}
\item \stClassName{StateMachineFactory} --- класс-фабрика для построения экземпляров автомата;
\item \stClassName{IStateMachine} --- базовый интерфейс автомата;
\item \stClassName{StateMachineManager} --- класс, реализующий базовые операции автомата;
\item \stClassName{IState} --- базовый интерфейс состояния автомата;
\item \stClassName{IStateFactory} --- базовый интерфейс класса-фабрики для построения экземпляров состояния;
\item \stClassName{Transition} --- переход;
\item \stClassName{Event} --- событие;
\item \stClassName{StateMachineImpl} --- реализация базового интерфейса автомата;
\item \stClassName{StatesTree} --- реализация дерева состояний;
\item \stClassName{StatesTreeController} --- реализация сложных действий на дереве состояний.
\end{itemize}

В заключение отметим, что в предыдущем разделе были перечислены некоторые особенности, которые
необходимо учесть при реализации предложенного паттерна. Они учтены при создании библиотеки следующим образом:
\begin{itemize}
\item алгоритм обработки события разбит на несколько частей и реализован в классах
\stClassName{StateMachineManager} и \stClassName{StatesTreeController};
\item дерево состояний реализовано в классе \stClassName{StatesTree}. Реализации сложных операций вынесены в класс 
\stClassName{StatesTreeController};
\item в качестве класса \stClassName{StateIdentifier} используется класс \stClassName{java.lang.Class}.
Благодаря этому, процесс построения экземпляра состояния в реализации интерфейса \stClassName{IStateFactory}
может быть унифицирован.
\end{itemize}
