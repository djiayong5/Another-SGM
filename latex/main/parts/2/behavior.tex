\section{Семантика}
\label{mysemantics}
Формальное описание семантики модели --- одна из основных задач этой работы. 

\subsection{Выполнение перехода}
Переход в предлагаемой модели выполняется по следующему алгоритму:

\begin{algorithm}
  \label{transition_processing_algorithm}
  \caption{Выполнение перехода}
  \INOUT{
    \NEWVAR{t}{Transition} --- переход, который требуется выполнить.
  }{
    Выполнить переход.
  }
  \begin{algtab}
    \PROCEDURE{void}{makeTransition}{\NEWVAR{t}{Transition}}
      \label{part1begin}
      \STATE{\NEWVAR{b}{State} = \FIELD{\VAR{a}}{target}}
      \STATE{\NEWVAR{l}{List<State>} = \NEW{ArrayList<State>}{}}
      \WHILE{!\METHODCALL{\VAR{b}}{isActive}{}}
        \STATE{\METHODCALL{\VAR{l}}{add}{\VAR{b}}}
        \STATE{\VAR{b} = \FIELD{\VAR{b}}{parent}}
      \ENDlabel{part1end}
      \label{part2}
      \STATE{\CALL{removeBranch}{\FIELD{\VAR{b}}{children}[0]}}
      \label{part3}
      \STATE{\METHODCALL{\FIELD{\VAR{t}}{action}}{run}{}}
      \label{part4begin}
      \STATE{\CALL{addChainToTree}{\VAR{l}, \VAR{b}}}
      \STATE{\CALL{fillBranch}{\FIELD{\VAR{B}}{children}[0]}}
      \label{part4end}
      \STATE{\CALL{startNewStates}{\FIELD{\VAR{B}}{children}[0]}}
    \END
  \end{algtab}
\end{algorithm}

Рассмотрим этот алгоритм подробнее. Разделим выполнение перехода на четыре этапа (рис.~\ref{perform_transition}). 
Пусть осуществляется переход в состояние $A$ (рис.~\ref{perform_transition}а).

\begin{figure}[htb]
  \centerline{
    \begin{tabular}{cc}
      \includegraphics{pic/performTransition.1}&\includegraphics{pic/performTransition.2}\\
      а&б\\
      \includegraphics{pic/performTransition.3}&\includegraphics{pic/performTransition.4}\\
      в&г
    \end{tabular}
  }
  \caption{Выполнение перехода}
  \label{perform_transition}
\end{figure}

Этап 1 (строки~\ref{part1begin}---\ref{part1end}). Пойдем от состояния $A$ вверх по дереву состояний 
до первого активного состояния. Пусть это состояние $B$ (рис.~\ref{perform_transition}б).

Этап 2 (строка~\ref{part2}). Заметим, что состояние $B$ обязано являться составным. Поэтому у него есть ровно 
один ребенок в дереве активных состояний. Отрежем всю ветку, соответствующую этому ребенку, 
выполнив предварительно действие при выходе для каждого состояния этой ветки. Используем для этого следующий 
алгоритм:

\begin{algorithm}
  \label{branch_removing_algorithm}
  \caption{Удаление ветки дерева состояний}
  \INOUT{
    \NEWVAR{a}{State} --- состояние, удаляемое из дерева текущих состояний.
  }{
    Удалить состояние и все его подсостояния, предварительно вызвав действие 
    при выходе, от детей к корню.
  }
  \begin{algtab}
    \PROCEDURE{void}{removeBranch}{\NEWVAR{a}{State}}
      \FOREACH{\NEWVAR{b}{State}}{\FIELD{\VAR{a}}{children}}
        \STATE{\CALL{removeBranch}{\VAR{b}}}
      \END
      \STATE{\METHODCALL{\VAR{a}}{exit}{}}
      \STATE{\METHODCALL{\FIELD{\VAR{a}}{parent}}{removeChild}{\VAR{a}}}
    \END
  \end{algtab}
\end{algorithm}

Отметим, что действие при выходе выполняется от детей к корню --- для подсостояний оно
всегда выполняется раньше, чем для надсостояний. Однако точный порядок специфицирован не будет. 
Один из возможных порядков выполнения действий при выходе отмечен на 
рис.~\ref{perform_transition}в цифрами от 1 до 5.
 
Этап 3 (строка~\ref{part3}). Выполним действие при переходе.

Этап 4 (строки~\ref{part4begin}---\ref{part4end}). Подвесим новую ветку к состоянию $B$, дополним ее 
состояниями так, чтобы выполнялись условия для активных состояний. Используем для этого следующий алгоритм:

\begin{algorithm}
  \label{branch_fill_algorithm}
  \caption{Дополнение ветки дерева недостающими состояниями}
  \INOUT{
    \NEWVAR{a}{State} --- корень заполняемой ветки.
  }{
    Дополнить ветку недостающими состояниями, чтобы получить корректное дерево активных состояний.
  }
  \begin{algtab}
    \PROCEDURE{void}{fillBranch}{\NEWVAR{a}{State}}
      \SWITCH{\FIELD{\VAR{a}}{stateType}}
        \CASE{\CONST{OR{\_}STATE}}
          \IF{\FIELD{\FIELD{\VAR{a}}{children}}{length} == 0}
            \STATE{\METHODCALL{\VAR{a}}{addChild}{\FIELD{\VAR{a}}{initial}}}
          \END
          \BREAK
        \CASE{\CONST{AND{\_}STATE}}
          \FOREACH{\NEWVAR{b}{State}}{\FIELD{\VAR{a}}{parts}}
            \IF{!\METHODCALL{b}{isActive}{}}
              \STATE{\METHODCALL{\VAR{a}}{addChild}{b}}
            \END
          \END
      \END
      \FOREACH{\NEWVAR{b}{State}}{\FIELD{\VAR{a}}{children}}      
        \STATE{\CALL{fillBranch}{b}}
      \END
    \END
  \end{algtab}
\end{algorithm}

Выполним для всех новых состояний действие при входе. Отметим, что такое действие, в отличие от действия при выходе, 
выполняется от корня к детям. Используем следующий алгоритм:

\begin{algorithm}
  \label{start_states_algorithm}
  \caption{Выполнение действия при входе для новых состояний}
  \INOUT{
    \NEWVAR{a}{State} --- корень новой ветки дерева активных состояний.
  }{
    Выполнить действие при входе для новых состояний, от корня к детям.
  }
  \begin{algtab}
    \PROCEDURE{void}{startNewStates}{\NEWVAR{a}{State}}
      \STATE{\METHODCALL{\VAR{a}}{start}{}}
      \FOREACH{\NEWVAR{b}{State}}{\FIELD{\VAR{a}}{children}}      
        \STATE{\CALL{startNewStates}{b}}
      \END
    \END
  \end{algtab}
\end{algorithm}

Точный порядок выполнения действий при входе также не будет специфицирован. Один из возможных порядков
отмечен на рис.~\ref{perform_transition}г цифрами от 1 до 5. 


\subsection{Обработка события}
\label{event_processing}
Будем считать, что система обрабатывает внешние события по одному, причем за время обработки 
новые внешние события не поступают. Будем действовать следующим образом: делегируем событие всем активным
состояниям, по возможности выполним активированные при этом переходы. Далее проделаем то же самое со
всеми полученными в процессе обработки внутренними событиями. Будем действовать так, пока система не придет
в устойчивое состояние. Эта идея реализована следующим алгоритмом:

\begin{algorithm}
  \label{event_processing_algorithm}
  \caption{Обработка события}
  \INOUT{
    \NEWVAR{e}{Event} --- пришедшее событие.
  }{
    Обработать событие.
  }
  \begin{algtab}
    \label{eventQueue}
    \STATE{\NEWVAR{eq}{Queue<Event>} = \NEW{LinkedList<Event>}{}}
    \label{transitionQueue}
    \STATE{\NEWVAR{tq}{Queue<Transition>} = \NEW{LinkedList<Transition>}{}}
    \PROCEDURE{void}{processEvent}{\NEWVAR{e}{Event}}
      \STATE{\CALL{offerEvent}{\VAR{e}}}
      \label{startProcess}
      \WHILE{!\METHODCALL{\VAR{eq}}{isEmpty}{}}
        \STATE{\CALL{delegateEventToStates}{\METHODCALL{\VAR{eq}}{remove}{}, \THISFIELD{activeStatesTreeRoot}}}
        \WHILE{!\METHODCALL{\VAR{tq}}{isEmpty}{}}
          \STATE{\NEWVAR{t}{Transition} = \METHODCALL{\VAR{tq}}{remove}{}}
          \IF{\METHODCALL{\FIELD{\VAR{t}}{source}}{isActive}{}}
            \STATE{\CALL{performTransition}{t}}                
          \END
        \END
      \ENDlabel{endProcess}
    \END
    \PROCEDURE{void}{offerEvent}{\NEWVAR{e}{Event}}
      \STATE{\METHODCALL{\VAR{eq}}{offer}{\VAR{e}}}
    \END
    \PROCEDURE{void}{offerTransition}{\NEWVAR{t}{Transition}}
      \STATE{\METHODCALL{\VAR{tq}}{offer}{\VAR{t}}}
    \END
  \end{algtab}
\end{algorithm}

Алгоритм работает следующим образом. Формируются очереди событий и переходов 
(строки~\ref{eventQueue}, \ref{transitionQueue}). Далее, пока очередь не опустеет,
приходящие события делегируются активным состояниям (строки~\ref{startProcess}---\ref{endProcess}).
Если в процессе обработки события активируется переход, то он добавляется в очередь
вызовом метода \t{offerTransition}. Если было активировано внутреннее событие, то оно добавляется
в очередь вызовом метода \t{offerEvent}.

Алгоритм делегирования события активным состояниям может быть различным в разных системах. Например,
в некоторых системах может быть удобно обрабатывать события от корня к детям, в других ---
от детей к корню, в третьих --- событие передается состоянию только если ни одно из его
подсостояний не обработало его~\cite{SAMEK}.

Для примера рассмотрим алгоритм делегирования состояний, обрабатывающий состояния от детей
к корню:

\begin{algorithm}
  \label{event_delegating_algorithm}
  \caption{Обработка события}
  \INOUT{
    \NEWVAR{e}{Event} --- обрабатываемое событие.
    \NEWVAR{a}{State} --- корень ветки дерева активных состояний, которой требуется передать на 
      обработку пришедшее событие.
  }{
    Передать пришедшее событие всем состояниям ветки от детей к корню.
  }
  \begin{algtab}
    \PROCEDURE{void}{delegateEventToStates}{\NEWVAR{e}{Event}, \NEWVAR{a}{State}}
      \FOREACH{\NEWVAR{b}{State}}{\FIELD{\VAR{a}}{children}}
        \STATE{\CALL{delegateEventToStates}{\VAR{e}, \VAR{b}}}
      \END
      \STATE{\METHODCALL{\VAR{a}}{processEvent}{\VAR{e}}}
    \END
  \end{algtab}
\end{algorithm}


\subsection{Классификация систем по степени детерминированности их поведения}
Заметим, что алгоритм, предложенный для обработки события, также не указывает точный порядок обработки
событий. Поэтому порядок выполнения переходов не однозначен. Кроме того, алгоритм выполнения перехода не 
указывает, в каком порядке выполнять действия при входе и выходе. Это может стать причиной недетерминированности 
поведения системы. 

Разобьем системы на три класса в зависимости от степени детерминированности их поведения.

\subsubsection{Сильно детерминированные системы}
Сильно детерминированными будем называть системы, при работе которых невозможны ситуации, 
когда у предложенного алгоритма обработки события будет выбор. 

Например, сильно детерминированной является любая система, диаграмма состояний которой представляет 
собой простой автомат (все состояния --- простые), в котором из каждого состояния 
по каждому событию существует не более одного перехода (рис.~\ref{simple_transitions}).

К сожалению, класс сильно детерминированных систем очень узок. Поэтому введем следующий класс.

\subsubsection{Слабо детерминированные системы}
Слабо детерминированными или детерминированными будем называть системы, при работе которых, 
независимо от того, какой недетерминированный выбор сделает алгоритм, общий эффект от обработки 
события окажется одним и тем же. Здесь под общим эффектом понимается изменение дерева активных состояний и 
изменение переменных окружения.

Например, система на рис.~\ref{deterministic_system} является детерминированной, но не сильно детерминированной. 
Действительно, если система находится в состоянии \t{(D, F)} и пришло событие \t{e}, то активируются 
переходы \t{(D$\to$E)} и \t{(F$\to$G)}. Они могут быть выполнены в любом порядке. Однако независимо от порядка 
их выполнения, система переходит в состояние \t{(E, G)}. Поэтому она является детерминированной. 

\drawfigure{pic/system_example.1}{Детерминированная система}{deterministic_system}

Если на переходах в схеме, изображенной на рис.~\ref{deterministic_system}, выполняются действия $z_1$ и $z_2$ 
(рис.~\ref{special_system}), то ее детерминированность существенно зависит от типа действий. 

\drawfigure{pic/system_example.2}{Детерминированность системы зависит от действий}{special_system}

Например, если действие $z_1: {a = 0}$, а действие $z_2: {a = 1}$, то такая система не является 
детерминированной, поскольку общий эффект действий зависит от порядка их выполнения.
 
Если же действие $z1: {a = 0}$, а действие $z_2: {b = 0}$, то такая система детерминирована, 
так как при любом порядке выполнения действий общий эффект остается одним и тем же: ${a = 0, b = 0}$.

Видимо, большинство асинхронных реактивных систем могут быть описаны в предложенной 
модели таким образом, чтобы быть детерминированными в данном смысле. 

\subsubsection{Недетерминированные системы}
Недетерминированные системы часто возникают в синхронных системах --- в системах, которые 
опрашивают внешние переменные с некоторым интервалом времени, и при определенных значениях этих переменных 
делают переходы и выполняют действия. В предложенной модели такие системы описываются с помощью 
введения одного события (назовем его \t{t}), которое будет посылаться системе на обработку через 
определенные интервалы времени.

Проблемы недетерминированности, возникающие в синхронных системах, связаны с тем, что за 
интервал времени сразу несколько внешних переменных могут изменить значение.    
 
Например, если на бомбе с часовым заводом (диаграмма состояний которой изображена на рис.~\ref{nondeterministic_system}), 
находящейся в состоянии <<\t{Детонация}>>, кнопка <<Отмена>> будет нажата в тот момент, когда 
закончится время, то в зависимости от того, какой переход выполнится первым, эффект может быть различным.


\drawfigure{pic/system_example.3}{Пример недетерминированной системы}{nondeterministic_system}

На практике, как правило, такие системы либо приводят к детерминированному виду 
(рис.~\ref{deterministic_version}), либо вообще оставляют это без внимания, считая, что при 
нескольких возможных вариантах, все они являются удовлетворительными. При этом принятое решение
зависит от реализации.

\drawfigure{pic/system_example.4}{Детерминированная версия системы}{deterministic_version}

\subsection{Примеры реализации других элементов диаграмм состояний \emph{UML} на базе описанной модели}
\label{another_elements}

Как отмечалось выше, предлагаемая модель содержит лишь основные элементы диаграмм состояний \emph{UML}. 
В этом разделе рассмотрим примеры реализации некоторых других элементов диаграмм состояний \emph{UML} 
при помощи описанной модели.

\subsubsection{Условное псевдосостояние}
Условное псевдосостояние --- это псевдосостояние, осуществляющее один из переходов в зависимости
от выполнения условий (рис.~\ref{condition_example}).

\drawfigure{pic/condition.1}{Пример диаграммы состояний, содержащей условное псевдосостояние}{condition_example}

В предлагаемой модели то же поведение можно реализовать так, как показано на рис.~\ref{condition_realization}.

\drawfigure{pic/condition.2}{Пример реализации условного псевдосостояния при помощи описанной модели}{condition_realization}

\subsubsection{Вилка}
Вилка --- это сложный переход с несколькими целевыми состояниями (рис.~\ref{fork_example}).

\drawfigure{pic/fork.1}{Пример диаграммы состояний, содержащей вилку}{fork_example}

В предлагаемой модели то же поведение можно реализовать так, как показано на рис.~\ref{fork_realization}.

\drawfigure{pic/fork.2}{Пример реализации вилки при помощи описанной модели}{fork_realization}

На основе изложенного материала опубликована следующая работа~\cite{SECR2006Mavrin}

