\chapter{Постановка задачи и описание метода ее решения} 
\label{chapter2}

В данной главе обосновывается необходимость улучшения существующих подходов, описывается новый метод.

\section{Задача}
SGM является оптимальным компромиссом качества и скорости по построению карт глубин на текущий момент. Для выполнения всех шагов алгоритма Semi-Global matching требуется $ O ( W \cdot H \cdot D) $ времени и $ O ( W \cdot H \cdot  D) $ памяти, где $W$ - ширина изображения, $H$ - высота изображения, $D$ - максимальная диспаратность. Ввиду того, что $D$ зависит от размера изображения, мы получаем нелинейное возрастание времени работы алгоритма от размера изображения. Несмотря на огромную разницу в производительности относительно глобальных алгоритмов, время работы SGM на больших изображениях слишком велико и не сопоставимо со временем работы локальных алгоритмов. Качество, полученных результатов, близко к качеству глобальных алгоритмов. Поэтому попробуем изменить метод SGM для повышения скорости работы без потери качества.


\section{Метрика качества карты стереоглубины}

Качество любых алгоритмов построения карт глубин измеряется с помощью специальных пар картинок, для которых вручную созданы карты. Алгоритму подается такая пара изображений, затем по полученной с помощью него карте делается сравнение с эталонной.  Для разных задач требуется разная точность диспаратностей, поэтому при измерении качества диспаратность пикселя считается верной, если соответствующий пиксель на эталоне отличается от текущего не более, чем на определенную велечину. 

Такая метрика характеризует качество алгоритма для только определенной погрешности, поэтому алгоритмы могут давать хорошие результаты с большой погрешностью и плохие с маленькой. 

В данной работе для измерения качества использовался сервис ~\cite{middlebury} на основе множества пар изображений с картами глубин для подсчёта качества.

\section{Метод с использованием приближенных вычислений карты глубины.}

Предлагаемый метод получает на вход пару изображений, карту глубины с большой погрешностью и возвращает карту глубины с меньшей. Приближенную карту глубины мы можем посчитать с помощью быстрого, например локального, алгоритма, который строит карту с хорошим качеством при большой погрешности. 

Стандартный Semi-Global Matching, как отмечалось в разделе \ref{sgm}, состоит из вычисления попиксельной стоимости, суммирования попиксельной стоимости и вычисления карт диспартности. Чтобы улучшить асимптотическую сложность всего алгоритма, понадобится модифицировать каждый этап стандартного алгоритма.

\subsection{Оптимизация вычисления попиксельной стоимости.}
В стандартной реализации Semi-Global Matching в препроцессинге производится расчет попиксельных стоимостей для каждого пикселя по всем диспаратностям за $O ( W \cdot H \cdot D)$. В моей работе было проверено три способа вычисления: подсчет всех стоимостей, вычисление без препроцессинга во время исполнения программы, подсчет стоимостей для каждого пикселя только для допустимых диспаратностей $[min, max]$, где $min$ и $max$  минимальное и максимальное значения возможной диспаратности в данном пикселе на основе приближенного вычисления.

Изменения на данном шагу алгоритма позволили уменьшить потребляюмую оперативную память и время выполнения, так как при использовании приближенной карты глубины мы пользуемся только частью предпосчитанной информации с помощью базового метода.

\subsection{Оптимизация суммирования попиксельной стоимости}
Шаг суммирования попиксельной стоимости реализован для поиска оптимальной конфигурации на основе только допустимых значений диспаратности.

Для некоторых точек алгоритм, используемый для поиска приближенной карты глубины, может не найти точки для сопоставления, либо выдавать низкий коэффициент доверия, такой алгоритм, например, представлен в работе~\cite{esgm}. Также такие точки могут быть найдены с помощью дополнительных эвристик после построения карты. Чтобы оставить возможность находить верное сопоставление было предложено два подхода по присвоению допустимых значений:
\begin{itemize}
\item $d(x,y) = [0; max\_disparity]$
\item $d(x, y) = d(x - 1, y)$
\end{itemize}

Для точек, где значения глубины являются достоверными по версии алгоритма, значение интервала допустимых диспаратностей указано в формуле~\ref{d_int}, где $error$ - допустимая погрешность в приближении, $width$ - ширина изображения, $d\_est(x,y)$ -  предположительная диспаратность в точке $(x,y)$, $d(x,y)$ - интервал допустимых диспаратностей в точке $(x,y)$.

\begin{equation}
\label{d_int}
d(x,y) = [ max(0,  d\_est(x,y) - error); min( width, d\_est(x,y) + error)]
\end{equation}

Алгоритм минимизации функционала с помощью динамического программирования модифицируется под обработку только допустимых диспартностей. В листинге~\ref{algo} показана реализации модификации. $[d\_min(p);  d\_max(p)]$ задают интервал допустимых значений диспаратности для точки $p$. Если для точки не существует точка, для которой эта точка следующая по направлению, то эта точка является "стартовой". Минимум из четырех стоимостей более подробно представлен на формуле~\ref{minimization2}

\begin{algorithm}[h!]
\caption{Метод минимизации функционала по одному из направлений.}
\label{algo}
\begin{algorithmic}[1]
 \STATE {Создать очередь обработки точек} $queue$
 \STATE {Добавить в очередь обработки точек все точки, которые являются "стартовыми точками" по данному направлению}
 \WHILE {(очередь не пуста)}
    \STATE {Вытащить первую точку из очереди} $p$
    \FOR{($d = d\_min(p)$ to $ d\_max(p)$)} 
	\STATE {$curr \leftarrow $ стоимость соответствия точек $(p.x, p.y)$ и $(p.x + d, p.y)$}
	\STATE {$best\_value \leftarrow $ минимум из четырех стоимостей по направлению с различными диспаратностями}
	\STATE {$l[p.x][p.y][d  - d\_min(p)] \leftarrow curr + best_value $}
    \ENDFOR
    \IF{(есть следующая точка за текущей по данному направлению)}
	\STATE {Добавить в очередь следующую точку}
   \ENDIF
  \ENDWHILE
\end{algorithmic}
\end{algorithm}

Заметим, что каждый пиксель обрабатывается один раз и для каждого пикселя проводится $(d\_max(p) - d\_min(p))$ действий, тогда количество действий, выполненных для всего изображения не будет превышать $(W \cdot H \cdot \max_{p} (d\_max(p) - d\_min(p)))$. Из полученной формулы, мы можем сделать вывод, что модифицированный алгоритм на основе второго подхода по присвоению допустимых значений имеет асимптотическую сложность $O(W \cdot H \cdot error)$ и имеет такие же затраты на память. 

Время работы первого подхода зависит от качества приближения базового алгоритма:  если для многих точек алгоритм не может найти соответствие, время выполнения модифицированного будет расти до времени SGM. В случае, если базовый алгоритм для многих точек возвращает значения глубины с большей погрешностью, чем $error$, качество результата может упасть. Поэтому очень важно выбирать входной алгоритм не только по времени быстродействия и качеству карты глубины, но и по типу ошибок алгоритма: алгоритм не нашел соответствие или вернул неверный результат.

